[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-24ddc0f5d75046c5622901739e7c5dd533143b0c8e959d652212380cedb1ea36.svg)](https://classroom.github.com/a/-ucQIGTc)
[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-718a45dd9cf7e7f842a935f5ebbe5719a5e09af4491e668f4dbf3b35d5cca122.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15221774&assignment_repo_type=AssignmentRepo)
# SE-Assignment-2
Assignment: Introduction to Software Engineering
Instructions:
Answer the following questions based on your understanding of software engineering concepts. Provide detailed explanations and examples where appropriate.

Questions:
1.Define Software Engineering:
  Software engineering is the process of developing, testing and deploying computer applications to solve real-world problems by adhering to a set of engineering principles and best practices

<What is software engineering, and how does it differ from traditional programming?>
   Software Development Life Cycle (SDLC):
   Software engineering is the process of developing, testing and deploying computer applications to solve real-world problems by adhering to a set of engineering principles and best practices while
   software engineering applies scientific and mathematical principles to the design, analysis and implementation of software systems. Programming, on the other hand, is mainly concerned with writing code to solve specific problems.
          SOFTWARE DEVELOPMENT LIFE CYCLE(SDLC);
               The software development lifecycle (SDLC) is the cost-effective and time-efficient process that development teams use to design and build high-quality software. The goal of SDLC is to minimize project risks through forward planning so that software meets customer expectations during production and beyond. This methodology outlines a series of steps that divide the software development process into tasks you can assign, complete, and measure.
                   SDLC PHASES;
                     Plan
                     The planning phase typically includes tasks like cost-benefit analysis, scheduling, resource estimation, and allocation. The development team collects requirements from several stakeholders such as customers, internal and external experts, and managers to create a software requirement specification document.

                     The document sets expectations and defines common goals that aid in project planning. The team estimates costs, creates a schedule, and has a detailed plan to achieve their goals.

                     <Design>
                      In the design phase, software engineers analyze requirements and identify the best solutions to create the software. For example, they may consider integrating pre-existing modules, make technology choices, and identify development tools. They will look at how to best integrate the new software into any existing IT infrastructure the organization may have.

                     <Implement>
                      In the implementation phase, the development team codes the product. They analyze the requirements to identify smaller coding tasks they can do daily to achieve the final result.

                     <Test>
                     The development team combines automation and manual testing to check the software for bugs. Quality analysis includes testing the software for errors and checking if it meets customer requirements. Because many teams immediately test the code they write, the testing phase often runs parallel to the development phase.

                     <Deploy>
                     When teams develop software, they code and test on a different copy of the software than the one that the users have access to. The software that customers use is called production, while other copies are said to be in the build environment, or testing environment.

                     Having separate build and production environments ensures that customers can continue to use the software even while it is being changed or upgraded. The deployment phase includes several tasks to move the latest build copy to the production environment, such as packaging, environment configuration, and installation.

                     <Maintain>
                     In the maintenance phase, among other tasks, the team fixes bugs, resolves customer issues, and manages software changes. In addition, the team monitors overall system performance, security, and user experience to identify new ways to improve the existing software.

           BENEFITS OF SDLC;
               >Increased visibility of the development process for all stakeholders involved
               >Efficient estimation, planning, and scheduling
               >Improved risk management and cost estimation
               >Systematic software delivery and better customer satisfaction

      "refferences:https://en.itpedia.nl/2019/07/12/wat-is-het-verschil-tussen-software-engineering-en-programmeren/"
      
      "refferences:https://www.geeksforgeeks.org/difference-between-software-engineering-process-and-conventional-engineering-processs/"
              

<Explain the various phases of the Software Development Life Cycle. Provide a brief description of each phase.>
    The details of the SDLC process vary for different teams. However, we outline some common SDLC phases below.

  Plan
  The planning phase typically includes tasks like cost-benefit analysis, scheduling, resource estimation, and allocation. The development team collects requirements from several stakeholders such as customers, internal and external experts, and managers to create a software requirement specification document.

  The document  sets expectations and defines common goals that aid in project planning. The team estimates costs, creates a schedule, and has a detailed plan to achieve their goals.

  Design
  In the design phase, software engineers analyze requirements and identify the best solutions to create the software. For example, they may consider integrating pre-existing modules, make technology choices, and identify development tools. They will look at how to best integrate the new software into any existing IT infrastructure the organization may have.

  Implement
  In the implementation phase, the development team codes the product. They analyze the requirements to identify smaller coding tasks they can do daily to achieve the final result.

  Test
  The development team combines automation and manual testing to check the software for bugs. Quality analysis includes testing the software for errors and checking if it meets customer requirements. Because many teams immediately test the code they write, the testing phase often runs parallel to the development phase.

  Deploy
  When teams develop software, they code and test on a different copy of the software than the one that the users have access to. The software that customers use is called production, while other copies are said to be in the build environment, or testing environment.

  Having separate build and production environments ensures that customers can continue to use the software even while it is being changed or upgraded. The deployment phase includes several tasks to move the latest build copy to the production environment, such as packaging, environment configuration, and installation.

  Maintain
  In the maintenance phase, among other tasks, the team fixes bugs, resolves customer issues, and manages software changes. In addition, the team monitors overall system performance, security, and user experience to identify new ways to improve the existing software.

  "refferences:https://www.split.io/blog/software-development-life-cycle-phases/#:~:text=The%20phases%20include%20requirements%2C%20design,testing%2C%20deployment%2C%20and%20maintenance.&text=This%20model%20involves%20repetitive%20cycles,product%20is%20achieved%20with%20success."

  "refferences:https://theproductmanager.com/topics/software-development-life-cycle/"




Agile vs. Waterfall Models:
<Compare and contrast the Agile and Waterfall models of software development. What are the key differences, and in what scenarios might each be preferred?>
  The agile model arranges the SDLC phases into several development cycles. The team iterates through the phases rapidly, delivering only small, incremental software changes in each cycle. They continuously evaluate requirements, plans, and results so that they can respond quickly to change. The agile model is both iterative and incremental, making it more efficient than other process models while the waterfall model arranges all the phases sequentially so that each new phase depends on the outcome of the previous phase. Conceptually, the design flows from one phase down to the next, like that of a waterfall.

   SCENARIOS WHERE EACH ARE PREFFERED;
    waterfall Model:The Waterfall Model is suitable when the project requirements are clear, unambiguous, and unlikely to change significantly during development.
    Agile Model:Agile is better suited for projects where stakeholders are closely involved every step of the way
   
   "refference:https://www.float.com/resources/agile-vs-waterfall"
   "refference:https://www.productplan.com/learn/agile-vs-waterfall/"



Requirements Engineering:
<What is requirements engineering? Describe the process and its importance in the software development lifecycle.>
    
   Requirement engineering is a systematic and strict approach to the definition, creation, and verification of requirements for a software system is known as requirements engineering. To guarantee the effective creation of a software product, the requirements engineering process entails several tasks that help in understanding, recording, and managing the demands of stakeholders.
   
   i)Feasibility Study
    The feasibility study mainly concentrates on Technical Feasibility,Operational Feasibility,Economic Feasibility.
  ii)Requirements Elicitation
    It is related to the various ways used to gain knowledge about the project domain and requirements. The various sources of domain knowledge include customers, business manuals, the existing software of the same type, standards, and other stakeholders of the project. The techniques used for requirements elicitation include interviews, brainstorming, task analysis, Delphi technique, prototyping, etc. Some of these are discussed here. Elicitation does not produce formal models of the requirements understood. Instead, it widens the domain knowledge of the analyst and thus helps in providing input to the next stage. 
iii)Requirements Specification
    This activity is used to produce formal software requirement models. All the requirements including the functional as well as the non-functional requirements and the constraints are specified by these models in totality. During specification, more knowledge about the problem may be required which can again trigger the elicitation process. The models used at this stage include ER diagrams, data flow diagrams(DFDs), function decomposition diagrams(FDDs), data dictionaries, etc.
 iv)Requirements Verification and Validation
    Verification: It refers to the set of tasks that ensures that the software correctly implements a specific function. 
    Validation: It refers to a different set of tasks that ensures that the software that has been built is traceable to customer requirements. If requirements are not validated, errors in the requirement definitions would propagate to the successive stages resulting in a lot of modification and rework.
  v)Requirements Management
    Requirement management is the process of analyzing, documenting, tracking, prioritizing, and agreeing on the requirement and controlling the communication with relevant stakeholders. This stage takes care of the changing nature of requirements. It should be ensured that the SRS is as modifiable as possible to incorporate changes in requirements specified by the end users at later stages too. Modifying the software as per requirements in a systematic and controlled manner is an extremely important part of the requirements engineering process.
      
      IMPORTANCE OF REQUIREMENT ENGINEERING IN SOFTWARE LIFE CYCLE
        >Helps ensure that the software being developed meets the needs and expectations of the stakeholders
        >Can help identify potential issues or problems early in the development process, allowing for adjustments 
         to be made before significant 
        >Helps ensure that the software is developed in a cost-effective and efficient manner
        >Can improve communication and collaboration between the development team and stakeholders
        >Helps to ensure that the software system meets the needs of all stakeholders.
        >Provides an unambiguous description of the requirements, which helps to reduce misunderstandings and 
         errors.
        >Helps to identify potential conflicts and contradictions in the requirements, which can be resolved 
         before the software development process begins.
        >Helps to ensure that the software system is delivered on time, within budget, and to the required quality 
         standards.
        >Provides a solid foundation for the development process, which helps to reduce the risk of failure.

   "refference:https://www.geeksforgeeks.org/software-engineering-requirements-engineering-process/"
   "refference:https://www.geeksforgeeks.org/software-engineering-requirements-engineering-process/ #requirements-engineering-process"
   "refference:https://www.geeksforgeeks.org/software-engineering-requirements-engineering-process/#advantages-of-requirements-engineering-process"


   
Software Design Principles:
<Explain the concept of modularity in software design. How does it improve maintainability and scalability of software systems?>
   Modularity in software design refers to the practice of dividing software into separate, independent modules, each responsible for a distinct feature or functionality. This approach promotes better maintainability, scalability, and reusability of code by isolating functional boundaries, making complex systems easier to manage and evolve.

   IMPROVES MAINTAINABILITY BY:
      By separating different functions in a software system into different units - modules - it becomes possible to change or correct a flaw in a module without affecting the other parts of the system. One can work on one module without affecting the others, and debugging and maintenance become simplified and easy.
   IMPROVES SCALABILITY BY:
       Adding modules  to enable more features or expand on existing features and functions. Scalability is important for software systems as they must be flexible enough to adapt to changing requirements.
       This gives a quick change or growth of a software system.
   
      

   "refference:https://www.ituonline.com/tech-definitions/what-is-modularity-in-software-design/#:~:text=Modularity%20is%20a%20fundamental%20design,the%20understandability%20of%20the%20system."
   "refference:https://www.javatpoint.com/modularity-in-software-engineering"


 Testing in Software Engineering:
<Describe the different levels of software testing (unit testing, integration testing, system testing, acceptance testing). Why is testing crucial in software development?>
    Software Testing checks the behavior of your application during the development process and prevents the occurrence of critical errors, saving your budget.

    i)Unit testing; 
     This the first level of testing. At this stage, developers test individual units of the system to make sure that they are usable.
  ii)Integration Testing
     During the Integration Testing, QA Engineers combine individual units and test them together as a group. The main purpose of this software testing level is to find bugs in the interaction of system units.
  iii)System Testing
     System Testing is the phase where a tester checks a complete and fully integrated system as a whole. At this stage, QA Engineers integrate all units to verify whether the developed product works properly and meets the specified requirements. 
  iv)Acceptance Testing
     This is the last level of software testing that is carried out before the product goes live. Testers conduct this type of testing to help the customer evaluate the obtained result and check whether the system meets the acceptance criteria. 

     BENEFITS OF SOFTWARE TESTING:
     During the development process, software products undergo four levels of testing: Unit Testing, Integration Testing, System Testing, and Acceptance Testing. Each of these stages is important and checks the parts of the project with the corresponding complexity. 

     A gradual increase in the number of code components in the test helps to easily detect system errors at an early stage and avoid failure of a software product. 

     Exposit provides high-quality software testing services using modern approaches and methodologies. We have strong skills in different types of testing and can help you with the full cycle of testing activities. Contact us if you value usability, performance, and function

  "refference:https://www.exposit.com/blog/4-levels-software-testing-how-develop-reliable-product/"


<What are version control systems, and why are they important in software development? Give examples of popular version control systems and their features.>
   Version control is defined as a system that tracks the progress of code across the software development lifecycle and its multiple iterations – which maintains a record of every change complete with authorship, timestamp, and other details – and also aids in managing change.

   IMPORTANCE OF VERSION CONTROLL
   
      Managing and Protecting the Source Code
      The Version Control System helps manage the source code for the software team by keeping track of all the code modifications. It also protects the source code from any unintended human error and consequences.

      Keeping Track of All the Modifications Made to the Code
      The team working on the project continuously produces new source codes and keeps making amendments to the existing code. These changes are recorded for future references and can be used if ever needed in the future to discover the root cause of any particular problem.

      Collaboration.

       Comparing Earlier Versions of the Code
       Since all the versions of the code are saved, this makes it possible for developers to go back at any time and compare the earlier versions of the code to help fix the mistake while reducing disruption to all team members.

       Backup

       Supports the Developers’ Workflow and Not any Rigid Way of Working
       Any suitable Version Control software will not impose any particular way of working. The Version Control Systems are known to provide a smooth and continuous flow of changes made to the code and prevent developers from getting frustrated in this clumsy mechanism.

    EXAMPLES OF VERSION CONTROL
    1. IBM Configuration Management Version Control (CMVC)
    2. Git
    3. Apache Subversion
    4. Azure DevOps
    5. Concurrent Versions System (CVS)
    6. Mercurial



   "refference: https://www.spiceworks.com/tech/devops/articles/what-is-version-control/"
   "refference:https://start.docuware.com/blog/document-management/what-is-version-control-why-is-it-important"
   "refference:https://www.simplilearn.com/tutorials/devops-tutorial/version-control"



Software Project Management:
<Discuss the role of a software project manager. What are some key responsibilities and challenges faced in managing software projects?>
   A project manager in software is responsible for leading a team of software developers and ensuring that software projects are completed on time, within budget, and to the satisfaction of the stakeholders. They are responsible for planning, executing, and closing projects

   RESPONSIBILITIES OF A SOFTWARE  PROJECT MANAGER
     >Preparing project proposals and discussing potential projects with clients and stakeholders
     >Facilitating project initiation by defining project scope and requirements, and preparing the necessary     documents and requirements
     >Developing project plans and timelines to ensure the timely submission of project deliverables
     >Managing project budgets and resources to ensure the timely completion of milestones
     >racking and documenting progress and communicating project status updates to key stakeholders
     >Identifying and managing project risks
     >Facilitating team meetings and collaboration
     >Liaising for changes and negotiations with relevant stakeholders
     >Ensuring software quality standards are met and requirements are submitted within budget and on time
     >Closing the project and ensuring proper documentation

     CHALLENGES FACED BY SOFTWARE PROJECT MANAGERS
       1. Scope creep
         Scope creep is a natural and expected phenomenon for any project. There are times when it can be beneficial but mostly the cons outweigh the pros.
       2. Lack of communication
         Miscommunication is dangerous for project teams because it affects their teamwork. It can cause conflicts among team members and can potentially delay the project.
       3. Lack of clear goals and success criteria
         Clarity is one of the most important requirements for the successful completion of the project and the lack of it creates several project management issues.
       4. Budgeting issues
          Most managers consider financial issues as one of the biggest hurdles in effective project management.
       
   "refference:https://project-management.com/project-manager-roles-responsibilities-software-projects/#:~:text=This%20involves%20defining%20project%20scope,is%20on%20the%20same%20page."
   "refference:https://kissflow.com/project/project-management-challenges/"

   

Software Maintenance:
<Define software maintenance and explain the different types of maintenance activities. Why is maintenance an essential part of the software lifecycle?>
   Software Maintenance refers to the process of modifying and updating a software system after it has been delivered to the customer.

    TYPES OF MAINTENANCE ACTIVITIES
     Bug Fixing: The process of finding and fixing errors and problems in the software.
     Enhancements: The process of adding new features or improving existing features to meet the evolving needs of the users.
     Performance Optimization: The process of improving the speed, efficiency, and reliability of the software.
     Porting and Migration: The process of adapting the software to run on new hardware or software platforms.
     Re-Engineering: The process of improving the design and architecture of the software to make it more maintainable and scalable.
     Documentation: The process of creating, updating, and maintaining the documentation for the software, including user manuals, technical specifications, and design documents.

     WHY MAINTENANCE
     1. Increased data security
       Thanks to software maintenance, reengineering data, bug fixing, and encoding constraints become easier, preventing the solution from being vulnerable. It even prepares you for worst-case scenarios, like a total blackout.
     2. Improved performance and efficiency
       Software maintenance ensures these outdated features and coding elements are removed or replaced with new functionalities. Subsequently, the software becomes adaptable to the latest industry trends and is not crippled by tech debt.
     3. Seamless project continuity
       With a clear software maintenance plan, enterprises can ensure that unforeseen circumstances don’t affect their projects and systems. Whether the servers are down or there is a sudden hike in user requests, software maintenance equips your enterprise software to withstand them and keep the projects going.
     4. Lower long-term total cost of ownership (TCO)
       Regular software maintenance practices like tech debt reduction, feature enhancement, and platform migration keep software stable, efficient, and modern.All this circumvent the need for frequent system overhauls or costly tech-refresh cycles, which reduces the overall cost of ownership over time. 

   "refference:https://www.geeksforgeeks.org/software-engineering-software-maintenance/"
   "refference:https://www.simform.com/blog/software-maintenance/"



Ethical Considerations in Software Engineering:
<What are some ethical issues that software engineers might face? How can software engineers ensure they adhere to ethical standards in their work?>
    1. Data Privacy
      It's impossible to talk about software ethics without talking about data privacy. The idea is simple: When a user trusts you with their data, you have to collect, process, and store it properly and securely.
    2.Accessibility
      Accessibility centers around diversity, inclusivity, and equal access to technology. Because software touches the lives of billions of people, engineers should aim to create digital worlds that are accessible to everyone, including those with disabilities.  
    3.Addictive Design
      Too many consumer apps use addictive design to keep their users engaged. Instead of a user interacting with an app because they enjoy using it, they interact with the app because its engineers implemented addictive mechanisms that encourage constant engagement and usage over a user's well-being. This is unethical. Addictive design features include:Excessive notifications, Endless feeds and autoplaying ,Social validation features,Reward and gamification features
    4.Algorithmic Bias
      Software has no inherent moral framework, but it may operate on datasets that are biased toward a certain group of users. This is particularly important in the field of AI, especially as AI becomes more powerful and takes on a more important role in our society. You have to make sure that the data you feed the algorithms is clean.
    5.Software Security
      software engineers should always ensure they write software that is stable and secure.

      ADHERING TO ETHICAL STANDARDS
      1.Protecting user privacy and data security: Ethical frameworks emphasize the importance of safeguarding user 
        information, ensuring that software applications are designed with robust security measures in place. This helps in building trust among users and protecting them from cybersecurity threats.
      2.Promoting fairness and inclusivity: Ethical frameworks encourage software engineers to consider the  
        potential biases in algorithms and address issues related to fairness and inclusivity. By designing applications that treat all users equally, software engineers can contribute to a more just society.
      3.Ensuring accountability: Ethical frameworks hold software engineers accountable for their actions. It 
       establishes a code of conduct that software engineers must adhere to, ensuring that they are conscious of the potential impact their work can have on individuals and society as a whole.


  "refference:https://x-team.com/blog/5-ethical-issues-in-software-development/"
  "refference:https://moldstud.com/articles/p-ethical-considerations-in-software-engineering#:~:text=Continuous%20Education%3A%20Software%20engineers%20must,and%20promoting%20ethical%20decision%2Dmaking."


Submission Guidelines:
Your answers should be well-structured, concise, and to the point.
Provide real-world examples or case studies wherever possible.
Cite any references or sources you use in your answers.
Submit your completed assignment by [due date].
